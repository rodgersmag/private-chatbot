#!/bin/bash

# Using Docker named volumes instead of local directories
echo "Setting up Docker volumes..."

# Check if volumes exist and create them if needed
POSTGRES_VOLUME="$(docker volume ls -q | grep postgres_data)"
STORAGE_VOLUME="$(docker volume ls -q | grep storage_data)"
FUNCTIONS_VOLUME="$(docker volume ls -q | grep functions_data)"

# Remove existing volumes if they exist (optional, uncomment if needed)
# if [ ! -z "$POSTGRES_VOLUME" ]; then
#     echo "Removing existing PostgreSQL volume..."
#     docker volume rm postgres_data
# fi
#
# if [ ! -z "$STORAGE_VOLUME" ]; then
#     echo "Removing existing Storage volume..."
#     docker volume rm storage_data
# fi
#
# if [ ! -z "$FUNCTIONS_VOLUME" ]; then
# echo "Removing existing Functions volume..."
# docker volume rm functions_data
# fi

echo "Docker will automatically create and manage the volumes"

# Stop any existing containers
echo "Stopping any existing containers..."
docker compose down



# Generate environment file and keys if they don't exist
echo "Setting up environment file and generating keys..."
./scripts/generate_anon_key.sh

# Generate SECRET_KEY if it's still the default value
echo "Checking SECRET_KEY..."
if [ -f ".env" ]; then
    # Extract current SECRET_KEY value (ignoring comments)
    CURRENT_SECRET_KEY=$(grep "^SECRET_KEY=" ".env" | cut -d '=' -f2 | cut -d '#' -f1 | tr -d ' ')
    
    # Check if it's still the default value
    if [ "$CURRENT_SECRET_KEY" = "changeme_super_secret_jwt_key_32_bytes_long" ] || [ -z "$CURRENT_SECRET_KEY" ]; then
        echo "Generating new SECRET_KEY..."
        # Generate a new 32-byte secret key
        NEW_SECRET_KEY=$(openssl rand -hex 32)
        
        # Replace the SECRET_KEY line in .env file, preserving the comment
        if [[ "$OSTYPE" == "darwin"* ]]; then
            # macOS version
            sed -i '' "s/^SECRET_KEY=.*/SECRET_KEY=$NEW_SECRET_KEY # <-- Will be auto-generated by start.sh/" ".env"
        else
            # Linux version
            sed -i "s/^SECRET_KEY=.*/SECRET_KEY=$NEW_SECRET_KEY # <-- Will be auto-generated by start.sh/" ".env"
        fi
        echo "New SECRET_KEY generated successfully"
    else
        echo "SECRET_KEY already configured"
    fi
else
    echo "Error: .env file not found"
    exit 1
fi

# Synchronize ANON_KEY with the backend
echo "Synchronizing ANON_KEY with the backend..."
# Check if ANON_KEY exists in .env file
if [ ! -f ".env" ]; then
    echo "Error: .env file not found. Please run scripts/generate_anon_key.sh first."
    exit 1
fi

ANON_KEY_CHECK=$(grep "^ANON_KEY=" ".env" | cut -d '=' -f2)
if [ -z "$ANON_KEY_CHECK" ]; then
    echo "Error: ANON_KEY not found in .env file. Please run scripts/generate_anon_key.sh first."
    exit 1
fi

echo "Found ANON_KEY in .env file: ${ANON_KEY_CHECK:0:5}..."
echo "ANON_KEY is now synchronized with the backend."
echo "The backend will use this key for anonymous authentication."

# Extract environment variables for sample apps
echo "Extracting environment variables for sample apps..."

# Path to main .env file
MAIN_ENV_FILE=".env"

# Check if main .env file exists
if [ ! -f "$MAIN_ENV_FILE" ]; then
    echo "Error: Main .env file not found. Please ensure it exists before running this script."
    exit 1
fi

# Extract ANON_KEY from main .env file
ANON_KEY=$(grep "^ANON_KEY=" "$MAIN_ENV_FILE" | cut -d '=' -f2)

if [ -z "$ANON_KEY" ]; then
    echo "Error: ANON_KEY not found in main .env file. Please ensure it's properly set."
    exit 1
fi

# Extract API URL from main .env file (REACT_APP_API_URL)
API_URL=$(grep "^REACT_APP_API_URL=" "$MAIN_ENV_FILE" | cut -d '=' -f2)

if [ -z "$API_URL" ]; then
    echo "Warning: REACT_APP_API_URL not found in main .env file. Using default localhost URL."
    API_URL="http://localhost:8000/api/v1"
fi

# Synchronize environment variables with sample apps
echo "Synchronizing environment variables with sample apps..."

# Extract STORAGE_SERVICE_EXTERNAL_URL from main .env file
STORAGE_URL=$(grep "^STORAGE_SERVICE_EXTERNAL_URL=" "$MAIN_ENV_FILE" | cut -d '=' -f2)

if [ -z "$STORAGE_URL" ]; then
    echo "Warning: STORAGE_SERVICE_EXTERNAL_URL not found in main .env file. Using default localhost URL."
    STORAGE_URL="http://localhost:8001"
fi

# Find all sample app directories that contain .env files or need them
SAMPLE_APPS_DIR="sample-apps"

if [ -d "$SAMPLE_APPS_DIR" ]; then
    # Find all subdirectories in sample-apps
    for app_dir in "$SAMPLE_APPS_DIR"/*; do
        if [ -d "$app_dir" ]; then
            APP_NAME=$(basename "$app_dir")
            APP_ENV_FILE="$app_dir/.env"
            
            echo "Processing sample app: $APP_NAME"
            
            # Create .env file if it doesn't exist
            if [ ! -f "$APP_ENV_FILE" ]; then
                echo "Creating .env file for $APP_NAME..."
                touch "$APP_ENV_FILE"
                echo "# SelfDB API URL" >> "$APP_ENV_FILE"
                echo "VITE_API_URL=$API_URL" >> "$APP_ENV_FILE"
                echo "" >> "$APP_ENV_FILE"
                echo "# Anonymous API Key" >> "$APP_ENV_FILE"
                echo "VITE_ANON_KEY=$ANON_KEY" >> "$APP_ENV_FILE"
                echo "" >> "$APP_ENV_FILE"
                echo "# Storage Service URL" >> "$APP_ENV_FILE"
                echo "VITE_STORAGE_URL=$STORAGE_URL" >> "$APP_ENV_FILE"
                echo "Created .env file for $APP_NAME"
                continue
            fi
            
            # Update VITE_API_URL
            if grep -q "^VITE_API_URL=" "$APP_ENV_FILE"; then
                if [[ "$OSTYPE" == "darwin"* ]]; then
                    sed -i '' "s|^VITE_API_URL=.*|VITE_API_URL=$API_URL|" "$APP_ENV_FILE"
                else
                    sed -i "s|^VITE_API_URL=.*|VITE_API_URL=$API_URL|" "$APP_ENV_FILE"
                fi
                echo "Updated VITE_API_URL in $APP_NAME"
            else
                echo "" >> "$APP_ENV_FILE"
                echo "# SelfDB API URL" >> "$APP_ENV_FILE"
                echo "VITE_API_URL=$API_URL" >> "$APP_ENV_FILE"
                echo "Added VITE_API_URL to $APP_NAME"
            fi
            
            # Update VITE_ANON_KEY
            if grep -q "^VITE_ANON_KEY=" "$APP_ENV_FILE"; then
                if [[ "$OSTYPE" == "darwin"* ]]; then
                    sed -i '' "s/^VITE_ANON_KEY=.*/VITE_ANON_KEY=$ANON_KEY/" "$APP_ENV_FILE"
                else
                    sed -i "s/^VITE_ANON_KEY=.*/VITE_ANON_KEY=$ANON_KEY/" "$APP_ENV_FILE"
                fi
                echo "Updated VITE_ANON_KEY in $APP_NAME"
            else
                echo "" >> "$APP_ENV_FILE"
                echo "# Anonymous API Key" >> "$APP_ENV_FILE"
                echo "VITE_ANON_KEY=$ANON_KEY" >> "$APP_ENV_FILE"
                echo "Added VITE_ANON_KEY to $APP_NAME"
            fi
            
            # Update VITE_STORAGE_URL
            if grep -q "^VITE_STORAGE_URL=" "$APP_ENV_FILE"; then
                if [[ "$OSTYPE" == "darwin"* ]]; then
                    sed -i '' "s|^VITE_STORAGE_URL=.*|VITE_STORAGE_URL=$STORAGE_URL|" "$APP_ENV_FILE"
                else
                    sed -i "s|^VITE_STORAGE_URL=.*|VITE_STORAGE_URL=$STORAGE_URL|" "$APP_ENV_FILE"
                fi
                echo "Updated VITE_STORAGE_URL in $APP_NAME"
            else
                echo "" >> "$APP_ENV_FILE"
                echo "# Storage Service URL" >> "$APP_ENV_FILE"
                echo "VITE_STORAGE_URL=$STORAGE_URL" >> "$APP_ENV_FILE"
                echo "Added VITE_STORAGE_URL to $APP_NAME"
            fi
            
            # Handle legacy variable names (for apps that might still use old naming)
            # Update VITE_SELFDB_URL if it exists (legacy naming)
            if grep -q "^VITE_SELFDB_URL=" "$APP_ENV_FILE"; then
                if [[ "$OSTYPE" == "darwin"* ]]; then
                    sed -i '' "s|^VITE_SELFDB_URL=.*|VITE_SELFDB_URL=$API_URL|" "$APP_ENV_FILE"
                else
                    sed -i "s|^VITE_SELFDB_URL=.*|VITE_SELFDB_URL=$API_URL|" "$APP_ENV_FILE"
                fi
                echo "Updated legacy VITE_SELFDB_URL in $APP_NAME"
            fi
            
            # Update VITE_SELFDB_STORAGE_URL if it exists (legacy naming)
            if grep -q "^VITE_SELFDB_STORAGE_URL=" "$APP_ENV_FILE"; then
                if [[ "$OSTYPE" == "darwin"* ]]; then
                    sed -i '' "s|^VITE_SELFDB_STORAGE_URL=.*|VITE_SELFDB_STORAGE_URL=$STORAGE_URL|" "$APP_ENV_FILE"
                else
                    sed -i "s|^VITE_SELFDB_STORAGE_URL=.*|VITE_SELFDB_STORAGE_URL=$STORAGE_URL|" "$APP_ENV_FILE"
                fi
                echo "Updated legacy VITE_SELFDB_STORAGE_URL in $APP_NAME"
            fi
            
            # Update VITE_SELFDB_ANON_KEY if it exists (legacy naming)
            if grep -q "^VITE_SELFDB_ANON_KEY=" "$APP_ENV_FILE"; then
                if [[ "$OSTYPE" == "darwin"* ]]; then
                    sed -i '' "s/^VITE_SELFDB_ANON_KEY=.*/VITE_SELFDB_ANON_KEY=$ANON_KEY/" "$APP_ENV_FILE"
                else
                    sed -i "s/^VITE_SELFDB_ANON_KEY=.*/VITE_SELFDB_ANON_KEY=$ANON_KEY/" "$APP_ENV_FILE"
                fi
                echo "Updated legacy VITE_SELFDB_ANON_KEY in $APP_NAME"
            fi
            
            echo "Synchronized $APP_NAME environment variables"
        fi
    done
    
    echo "All sample apps synchronized with environment variables."
else
    echo "Sample apps directory not found. Skipping sample app synchronization."
fi

# Start the services
echo "Starting SelfDB services..."
docker compose up -d --build

# Check if services are running
echo "Checking service status..."
docker compose ps

echo "SelfDB is now running!"
echo "- Frontend: http://localhost:3000"
echo "- API: http://localhost:8000"
echo "- Storage service: http://localhost:8001"
